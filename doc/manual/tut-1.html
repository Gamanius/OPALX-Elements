<html>
<head>
<title>IPPL  Tutorial 1: A Laplace Solver Using Simple Jacobi Iteration</title>
<link rel=StyleSheet href="http://amas.web.psi.ch/css/basic-style.css" type="text/css">
</head>
<body bgcolor="#FFFFFF">
<h1>IPPL&nbsp; Tutorial 1: A Laplace Solver Using Simple Jacobi Iteration</h1>
<p><b>Contents:</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#intro">Introduction</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#laplace">Laplace's Equation</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#sequential">A Sequential Solution</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#pooma">Using Intervals</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#refinements">Some Refinements</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#affinity">A Note on Affinity</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#summary">Summary</a>

<!---------------------------------------------------------------------->
<a name="intro"><h2>Introduction</h2></a>

<p>This tutorial introduces two of the most commonly used classes in
IPPL&nbsp;: <tt>Array&lt;&gt;</tt>, which is used to store data,
and <tt>Interval&lt;&gt;</tt>, which is used to specify a subsection
of an array.  The key ideas introduced in this tutorial are:
<ul>
<li>the use of whole-array operations, such as scalar-to-array
assignment and elementwise addition; and
<li>the use of intervals to specify array sections.
</ul>

<!---------------------------------------------------------------------->
<a name="laplace"><h2>Laplace's Equation</h2></a>

<p>Our first IPPL&nbsp; program solves Laplace's equation on a
regular grid using simple Jacobi iteration.  Laplace's equation in two
dimensions is:

<center><em>
d<sup>2</sup>V/dx<sup>2</sup> + d<sup>2</sup>V/dy<sup>2</sup> = 0
</em></center>

<p>where <em>V</em> is, for example, the electric potential in a flat
metal sheet.  If we approximate the second derivatives in <em>x</em>
and <em>y</em> using a difference equation, we obtain:

<center><em>
V(i, j) = (V(i+1, j) + V(i, j+1) + V(i-1, j) + V(i, j-1)) / 4
</em></center>

<p>i.e. the voltage at any point is the average of the voltages at
neighboring points.  This formulation also gives us a way to solve
this equation numerically: given any initial guess for the voltage
<em>V<sub>0</sub></em>, we can calculate a new guess
<em>V<sub>1</sub></em> by using <em>V<sub>0</sub></em> on the right
hand side of the equation above.  We can then use the calculated
<em>V<sub>1</sub></em> to calculate a new guess
<em>V<sub>2</sub></em>, and so on.

<p>This process, called Jacobi iteration, is the simplest in a family
of relaxation methods than can be used to solve a wide range of
problems.  All relaxation methods iterate toward convergence, and use
some kind of nearest-neighbor updating scheme, or <em>stencil</em>.
The stencil for Jacobi iteration, for example, consists of five points
arranged in a cross; other, larger stencils lead to different update
rules, and different convergence rates.  One of the main goals of
IPPL&nbsp; was to make it easy for programmers to specify and
implement stencil-based algorithms of this kind.

<p>If we add charged particles to the system, we obtain Poisson's
equation:

<center><em>
d<sup>2</sup>V/dx<sup>2</sup> + d<sup>2</sup>V/dy<sup>2</sup> = &szlig;
</em></center>

<p>where &szlig; specifies the charge distribution.  The solution to
this equation can also be calculated using a relaxation method such as
Jacobi iteration; the update equation is:

<center><em>
V(i, j)<sub>new</sub> = (V(i+1, j) + V(i, j+1) + V(i-1, j) + V(i, j-1) - &szlig;(i, j))/4
</em></center>

<!---------------------------------------------------------------------->
<a name="sequential"><h2>A Sequential Solution</h2></a>

<p>Our first version of Jacobi iteration models a flat plate with a
unit charge in its center using a 20&times;20 array, and uses
IPPL&nbsp;'s arrays conventionally, by looping over their elements.
(This program is included in the release as
<tt>examples/Solvers/Sequential</tt>.)  There is nothing wrong with
using the library this way---IPPL&nbsp;'s arrays are still very
fast, and memory-efficient---but when compared with the refined
program shown later, this code is longer and harder to read.

<blockquote><pre>
#include "Ippl."
#include &lt;iostream.h&gt;

// <em>The size of each side of the domain.</em>
const int N = 20;

int
main(
    int                 argc,           // <em>argument count</em>
    char *              argv[]          // <em>argument list</em>
){
    // <em>Initialize Ippl.</em>
    Ippl::initialize(argc, argv);

    // <em>The array we'll be solving for</em>
    Array&lt;2&gt; V(N, N);

    // <em>The right hand side of the equation (spike in the center)</em>
    Array&lt;2&gt; b(N, N);

    // <em>Initialize.</em>
    for (int i=0; i&lt;N; ++i){
        for (int j=0; j&lt;N; ++j){
            V(i, j) = 0.0;
            b(i, j) = 0.0;
        }
    }
    b(N/2, N/2) = -1.0;

    // <em>Iterate 200 times.</em>
    Array&lt;2&gt; temp(N, N);
    for (int iteration=0; iteration&lt;200; ++iteration)
    {
        // <em>Use interior of V to fill temp</em>
        for (int i=1; i&lt;N-1; ++i){
            for (int j=1; j&lt;N-1; ++j){
                temp(i, j) = 0.25*(V(i+1,j) + V(i-1,j) + V(i,j+1) + V(i,j-1) - b(i,j));
            }
        }
        // <em>Use temp to fill V</em>
        for (int i=1; i&lt;N-1; ++i){
            for (int j=1; j&lt;N-1; ++j){
                V(i, j) = temp(i, j);
            }
        }
    }

    // <em>Print out the result</em>
    for (int j=0; j&lt;N; ++j){
        for (int i=0; i&lt;N; ++i){
            cout &lt;&lt; V(i, j) &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }

    // <em>Clean up Ippl and report successful execution.</em>
    Ippl::finalize();
    return 0;
}
</pre></blockquote>

<!---------------------------------------------------------------------->
<a name="pooma"><h2>Using Intervals</h2></a>

<p>The program shown above is not much of an advance over its C
equivalent.  The programmer is still required to loop over data
elements explicitly, even though these loops all take the same form.
A better implementation of Jacobi iteration is shown below (and
included in the release as <tt>examples/Solvers/SimpleJacobi</tt>).
This version uses <tt>Interval&lt;&gt;</tt> objects to specify index
ranges, which eliminates the need for the explicit loops of the first
version.

<blockquote><pre>
01  #include "Ippl/Arrays.h"
02
03  #include &lt;iostream.h&gt;
04
05  // <em>The size of each side of the domain.</em>
06  const int N = 20;
07  
08  int
09  main(
10      int                 argc,           // <em>argument count</em>
11      char *              argv[]          // <em>argument list</em>
12  ){
13      // <em>Initialize Ippl.</em>
14      Ippl::initialize(argc, argv);
15
16      // <em>The array we'll be solving for</em>
17      Array&lt;2&gt; V(N, N);
18      V = 0.0;
19
20      // <em>The right hand side of the equation (spike in the center)</em>
21      Array&lt;2&gt; b(N, N);
22      b = 0.0;
23      b(N/2, N/2) = -1.0;
24
25      // <em>Specify the interior of the domain</em>
26      Interval&lt;1&gt; I(1, N-2), J(1, N-2);
27
28      // <em>Iterate 200 times</em>
29      for (int iteration=0; iteration&lt;200; ++iteration)
30      {
31          V(I,J) = 0.25*(V(I+1,J) + V(I-1,J) + V(I,J+1) + V(I,J-1) - b(I,J));
32      }
33
34      // <em>Print out the result</em>
35      cout &lt;&lt; V &lt;&lt; endl;
36
37      // <em>Clean up Ippl and report success.</em>
38      Ippl::finalize();
39      return 0;
40  }
</pre></blockquote>

<p>The first three lines of this program include the two header files
needed to write IPPL&nbsp; programs, and the standard C++ I/O
streams header file.  <tt>Ippl/Arrays.h</tt> includes all the
declarations of the basic IPPL&nbsp; library interface functions.
These general routine are used to initialize, query, and shut down the
IPPL&nbsp; library environment, including the underlying run-time
system.

<p><tt>Ippl/Arrays.h</tt> also includes header files that define
IPPL&nbsp;'s arrays.  These arrays are not actually data
containers, but rather handles on data containers through which
programs can read, write, and apply operations to N-dimensional sets
of elements.  As we shall see, it is possible for many arrays to refer
to the same underlying data in different ways.

<p>The next statement in this program, at line&nbsp;6, defines the
size of our problem domain.  In order to keep this code simple, this
size is made a constant, and the array is made square.  Real
applications will usually employ variable-sized domains, and put off
decisions about the actual sizes of arrays until run-time.

<p>The function <tt>Ippl::initialize()</tt>, which is called at
line&nbsp;14, initializes some of IPPL&nbsp;'s internal data
structures.  This function looks for certain IPPL&nbsp;-specific
arguments in the program's command-line argument list, strips them
out, and returns a possibly-shortened list.  Programs should call
<tt>Ippl::initialize()</tt> before calling any functions or methods
from the IPPL&nbsp; library that might do operations in parallel.
(They can alternatively use <tt>Ippl::Options</tt>, as described
in the <a href="">appendix</a>.)
In practice, this means that it is generally a bad idea to declare
IPPL&nbsp; objects as global variables, even if the program is not
parallel when it is first written, since their presence can impede
future portability.

<p>Line&nbsp;17 actually declares an array.  The first thing to notice
is that the rank of the array (i.e. the number of dimensions is has)
is a template parameter to the class <tt>Array&lt;&gt;</tt>, while the
initial dimensions of the array are given as constructor parameters.
If we wanted to create a 3-dimensional array, we could change this
line to be something like:

<blockquote><pre>
Array&lt;3&gt; V(SizeX, SizeY, SizeZ);
</pre></blockquote>

<p>When the array <tt>V</tt> is created, IPPL&nbsp; realizes that
some storage has to be created for it as well, and so it creates an
actual data area at this point.  When the assignment statement on the
next line (line&nbsp;18) is executed, IPPL&nbsp; sees an array
target, but a scalar value, so it fills the whole array with the
scalar's value.

<p>Lines 21-23 create and initialize the array that stores the charge
distribution term &szlig;.  This array's values are fixed: there is a
single negative unit charge in the center of the world, and no other
charges anywhere else.  Note how line&nbsp;22 uses scalar-to-array
assignment, while line&nbsp;23 assigns to a single element of the
array <tt>b</tt> using conventional subscripting.  IPPL&nbsp;'s
arrays have many advanced features, but they also support mundane
operations, such as reading or writing a particular location.

<p>Line&nbsp;26 introduces the <tt>Interval&lt;&gt;</tt> class.  An
<tt>Interval&lt;&gt;</tt> specifies a contiguous range of index
values; the integer template argument to <tt>Interval&lt;&gt;</tt>
specifies the interval's rank, while the constructor arguments specify
the low and high ends of the interval's value.  Thus, since <tt>N</tt>
is fixed at 20 in this program, both <tt>I</tt> and <tt>J</tt> specify
the one-dimensional interval from 1 to 19 inclusive.

<p>Intervals are used to select sections of arrays using a
Fortran&nbsp;90-like syntax.  Intervals and integers may be freely
mixed when indexing an array; if any index in an expression is an
interval, the result is a temporary alias for the specified array
section.  This alias is itself an array, since arrays are just
lightweight handles on underlying data storage objects.  The
expression <tt>V(I,J)</tt> therefore returns a temporary array which
aliases the interior of the same storage used by the array <tt>V</tt>.

<p>Note that since the array <tt>V</tt> is square, the program could
have declared a single <tt>Interval&lt;&gt;</tt> spanning
1..<tt>N</tt>-2, and used it to index <tt>V</tt> along both axes.
However, the code is easier to read, and easier to modify to handle
non-square domains, if two separate <tt>Interval&lt;&gt;</tt>s are
used.

<p>The loop spanning lines 29-32 performs the Jacobi relaxation.  As
discussed earlier, this consists of repeatedly averaging the charge
distribution <tt>b</tt> at each location, and the values in <tt>V</tt>
that are adjacent to that location, and then updating the location
with that average.  These calculations are done in parallel, i.e. they
appear to be calculated simultaneously for all elements in the array.
This is accomplished by using the <tt>Interval&lt;&gt;</tt>s declared
on line&nbsp;26 to select sections of <tt>V</tt> with appropriate
offsets, and then relying on overloaded addition and subtraction
operators to combine these sections.  For example, the expression
<tt>V(I,J+1)</tt> selects those elements <tt>V(i,j)</tt> of <tt>V</tt>
for which <tt>i</tt> is in the range 1..<tt>N</tt>-2, and <tt>j</tt>
is in the range 2..<tt>N</tt>-1, i.e. offset upward in the second
dimension by one step.  As can be inferred, arithmetic on
<tt>Interval&lt;&gt;</tt>s works in the obvious way: for example,
adding an integer adjusts all the elements of the
<tt>Interval&lt;&gt;</tt> upward or downward.

<p>Note that the assignment on line&nbsp;31 automatically creates a
temporary copy of the array <tt>V</tt>, so that values are not read
while they are being overwritten.  IPPL&nbsp; automatically detects
cases in which the stencils on the reading side of an assignment
overlap the stencils on the assignment's writing side, and creates
temporaries as needed to avoid conflicts.  The program shown in the
next tutorial avoids the creation of temporaries simply by using
non-overlapping stencils.

<p>The statement on line&nbsp;35 prints out the whole of the array
<tt>V</tt>.  IPPL&nbsp; overloads the usual stream operators
(<tt>&lt;&lt;</tt> and <tt>&gt;&gt;</tt>) to handle most of the
objects in the library sensibly.  In this case, the output expression
prints the elements of <tt>V</tt> a row at a time, putting each row on
a separate line.  Finally, line&nbsp;38 calls the cleanup routine
<tt>Ippl::finalize()</tt>, which complements the earlier call to
<tt>Ippl:initialize()</tt> on line&nbsp;14, and returns 0 to indicate
successful completion.

<!---------------------------------------------------------------------->
<a name="refinements"><h2>Some Refinements</h2></a>

<p>One thing that isn't shown in the program above is the precision of
the calculations.  To find out what this is, we can inspect the
declaration of the class <tt>Array&lt;&gt;</tt> in the IPPL&nbsp;
header file <tt>Array.h</tt>:

<blockquote><pre>
template &lt; int Dim,
           class T         = IPPL_DEFAULT_ARRAY_ELEMENT_T,
           class EngineTag = IPPL_DEFAULT_ARRAY_ENGINE &gt;
class Array : ...
{
    ...
};
</pre></blockquote>

<p>The class <tt>Array&lt;&gt;</tt> has three template parameters: the
number of dimensions, the element data type, and an engine tag that
specifies how the underlying data is actually stored.  We will discuss
engines and engine tags in more detail in subsequent tutorials.

<p>What makes this templated class declaration different from others
we have seen so far is that default values are supplied for two of its
three type parameters.  The macros
<tt>IPPL_DEFAULT_ARRAY_ELEMENT_T</tt> and
<tt>IPPL_DEFAULT_ARRAY_ENGINE</tt> are defined in the header file
<tt>IpplConfiguration.h</tt>.  The first specifies the default
element type of arrays, while the second specifies their default
storage mechanism.  The default for the first is <tt>double</tt>,
while the default for the second specifies dense, rectangular storage.

<p>There are therefore two ways to change the precision of the
calculations in the program above.  One is to re-define
<tt>IPPL_DEFAULT_ARRAY_ELEMENT_T</tt>:

<blockquote><pre>
#ifdef IPPL_DEFAULT_ARRAY_ELEMENT_T
#undef IPPL_DEFAULT_ARRAY_ELEMENT_T
#endif
#define IPPL_DEFAULT_ARRAY_ELEMENT_T float
#include "Ippl/Arrays.h"
</pre></blockquote>

<p>The "undefinition" is needed because some compilers automatically
read a "prefix file" before any other headers.  This <tt>#define</tt>
must come before any of IPPL&nbsp;'s header files are included to
ensure that all instantiations of all IPPL&nbsp; classes are done
with the same default in effect.

<p>The second, and more modular, way to change the precision of this
Laplace solver is to specify the data types of the arrays explicitly:

<blockquote><pre>
14  Array&lt;2<b>, float</b>&gt; V(N, N);
    ...
18  Array&lt;2<b>, float</b>&gt; b(N, N);
</pre></blockquote>

<p>This is generally considered better practice, as it is clear at the
point of declaration what the data type of each array is, and because
it makes it easier for programmers to combine classes written that
have been written independently.  Changing the default engine type,
for example, could have a dramatic---probably dramatically
bad---effect on the performance of a set of linear solver classes.

<p>It is also generally considered good practice to use
<tt>typedef</tt>s to ensure the consistency of array definitions.
For example, the Laplace solver could be written as follows:

<blockquote><pre>
    typedef double LaplaceDataType_t;
    typedef Array&lt;2, LaplaceDataType_t&gt; LaplaceArrayType_t;
    ...
14  LaplaceArrayType_t V(N, N);
    ...
18  LaplaceArrayType_t b(N, N);
</pre></blockquote>

<p>Declaring types explicitly in this way might seem unnecessarily
fussy in a small program such as this.  However, all programs have a
tendency to grow, and finding and modifying dozens of object
declarations after the fact is much more tedious and error-prone than
defining a type once, in one place, and then using it consistently
through the rest of the program.

<p>One final note on this program: it might seem cumbersome to declare
the array on line&nbsp;17, then initialize it with an assignment on
the next line, instead of providing an initial value for the array's
elements with an extra constructor argument.  IPPL&nbsp; requires
this in order to avoid ambiguity regarding what is a dimension, and
what is an initial value.  Since a single templated class
<tt>Array&lt;&gt;</tt> is used for arrays of any dimension up to
seven, it must provide constructors taking up to seven arguments which
between them specify the array's dimensions.  If we let <tt>Sub1</tt>,
<tt>Sub2</tt>, and so on represent classes that can legally be used to
specify dimensions (such as <tt>int</tt> or <tt>Interval</tt>), then
<tt>Array&lt;&gt;</tt> must have constructors like the ones shown
below:

<blockquote><pre>
template &lt; int Dim,
           class T         = IPPL_DEFAULT_ARRAY_ELEMENT_T,
           class EngineTag = IPPL_DEFAULT_ARRAY_ENGINE &gt;
class Array : ...
{
  public :
    template&lt;class Sub1&gt;
    Array(const Sub1 &amp; s1);

    template&lt;class Sub1, class Sub2&gt;
    Array(const Sub1 &amp; s1, const Sub2 &amp; s2);

    template&lt;class Sub1, class Sub2, class Sub3&gt;
    Array(const Sub1 &amp; s1, const Sub2 &amp; s2, const Sub3 &amp; s3);

    <em>etc.</em>
};
</pre></blockquote>

<p>Suppose that <tt>Array&lt;&gt;</tt> also included constructors that
took an initial value for the array's elements as an argument:

<blockquote><pre>
template &lt; int Dim,
           class T         = IPPL_DEFAULT_ARRAY_ELEMENT_T,
           class EngineTag = IPPL_DEFAULT_ARRAY_ENGINE &gt;
class Array : ...
{
  public :
    template&lt;class Sub1&gt;
    Array(const Sub1 &amp; s1, T initial_value);

    template&lt;class Sub1, class Sub2&gt;
    Array(const Sub1 &amp; s1, const Sub2 &amp; s2, T initial_value);

    <em>etc.</em>
};
</pre></blockquote>

<p>Declarations such as the following would then be ambiguous:

<blockquote><pre>
Array&lt;2, int&gt; w(8, 5);
</pre></blockquote>

<p>since the compiler would not be able to tell whether the two
arguments were to be interpreted as dimensions, or as a dimension and
an initializer.  If C++ provided a way to "hide" constructors based on
the value of a template argument, so that only the constructors for
N-dimensional arrays could be called for <tt>Array&lt;N&gt;</tt>, this
problem wouldn't arise.  Since there is no such mechanism,
IPPL&nbsp; requires programmers to specify initial values by
wrapping them in a templated class.  This is done as shown in the
following declaration:

<blockquote><pre>
Array&lt;2&gt; w(5, 7, modelElement(3.14));
</pre></blockquote>

<p>The function <a name="modelElement"><tt>modelElement()</tt></a>
does nothing except return an instance of
<tt>ModelElement&lt;T&gt;</tt>, where <tt>T</tt> is the type of
<tt>modelElement()</tt>'s argument.  The <tt>ModelElement&lt;&gt;</tt>
class in its turn only exists to provide enough type information for
the compiler to distinguish between initializers and dimensions; the
corresponding constructors of <tt>Array&lt;&gt;</tt> are:

<blockquote><pre>
template &lt; int Dim,
           class T         = IPPL_DEFAULT_ARRAY_ELEMENT_T,
           class EngineTag = IPPL_DEFAULT_ARRAY_ENGINE &gt;
class Array : ...
{
  public :

    // <em>constructors for 1-dimensional arrays</em>
    template&lt;class Sub1&gt;
    Array(const Sub1 &amp; s1);

    template&lt;class Sub1&gt;
    Array(const Sub1 &amp; s1, modelElement&lt;T&gt; initial_value);

    // <em>constructors for 2-dimensional arrays</em>
    template&lt;class Sub1, class Sub2, class Sub3&gt;
    Array(const Sub1 &amp; s1, const Sub2 &amp; s2, const Sub3 &amp; s3);

    template&lt;class Sub1, class Sub2&gt;
    Array(const Sub1 &amp; s1, const Sub2 &amp; s2, modelElement&lt;T&gt; initial_value);

    <em>etc.</em>
};
</pre></blockquote>

<p>Note that the function <tt>modelElement()</tt> is just a
programming convenience: its only real purpose is to save programmers
the trouble of typing:

<blockquote><pre>
Array&lt;2&gt; w(5, 7, ModelElement&lt;double&gt;(3.14));
</pre></blockquote>

<!---------------------------------------------------------------------->
<a name="affinity"><h2>A Note on Affinity</h2></a>

<p>In some shared-memory machines, such as SGI Origins, every
processor can access memory everywhere in the machine, but there is
still a difference between "local" and "remote" memory.  The memory
chips are physically located with particular processors, so when
processor&nbsp;0 accesses memory that is actually stored with
processor&nbsp;127, the access is on average about 3-4 times slower
than if processor&nbsp;0 accesses its own memory.  This only arises on
very large machines---computers with up to 8 processors generally have
truly symmetric memory.

<p>When a program dynamically allocates memory on such a machine, the
pages get mapped into the memory that is located with the CPU that
first touches the memory.  That is not necessarily the CPU that
requested the allocation, since many pages could be allocated in one
logical operation and pointers to them could be handed to other CPUs
before being dereferenced.

<p>Thus, both memory and threads can have an affinity for particular
processors.  A chunk of memory has affinity for a particular CPU, and
the thread scheduler can give a thread affinity for a CPU.

<p>The difficulty that arises is that if the thread that is running
the user's code initializes the memory for an <tt>Array&lt;&gt;</tt>
with the <a href="tut-1.html#modelElement"><tt>modelElement()</tt></a>
function mentioned in the first tutorial, all of the memory gets
mapped to the CPU where that thread is running, instead of to a CPU
across the machine.

<p>One solution to this problem would be for the constructor that
takes a <tt>ModelElement&lt;&gt;</tt> to generate the iterates that
fill the memory, and then farm them out to the proper threads, so that
the memory is mapped where the program actually wants it.  This
optimization is not in this release of IPPL&nbsp;, but will be
considered for future releases.

<!---------------------------------------------------------------------->
<a name="summary"><h2>Summary</h2></a>

<p>This tutorial has shown that IPPL&nbsp;'s <tt>Array&lt;&gt;</tt>
class can be indexed sequentially, like a normal C or C++ array.  It
can also be indexed using <t>Interval&lt;&gt;</t> objects, each of
which specifies a contiguous range of indices.  When an
<tt>Array&lt;&gt;</tt> is indexed using an <tt>Interval&lt;&gt;</tt>,
the result itself acts like an array.  Overloaded operators can be
used to perform arithmetic and assignment on both arrays and selected
array sections.  Finally, the elementary data type of arrays can be
changed globally by redefining a macro, or for individual arrays by
overriding the default value of the <tt>Array&lt;&gt;</tt> template's
second type parameter.  The latter is considered better programming
practice, particularly when <tt>typedef</tt> is used to localize the
type definition.

<br>
<br>
<center>
<table>
<tr>	<td><a href="background.html">[Prev]</a>
	<td><a href="index.html">[Home]</a>
	<td><a href="tut-2.html">[Next]</a>
	</tr>
</table>
</center>

</body>
</html>
