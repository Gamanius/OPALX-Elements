<html>
<head>
<title>IPPL Tutorials - Introduction</title>
<link rel=StyleSheet href="http://amas.web.psi.ch/css/basic-style.css" type="text/css">
</head>
<body bgcolor="#FFFFFF">

<h1>IPPL Tutorials - Introduction</h1>

<center><h1>IPPL Tutorials<br>Introduction</h1></center>

<p>This document is an introduction to IPPL, a C++ class
library for high-performance scientific computation.  IPPL
runs efficiently on single-processor desktop machines, shared-memory
multiprocessors, and parallel supercomputers containing dozens or
hundreds of processors.  What's more, by making extensive use of the
advanced features of the ANSI/ISO C++ standard---particularly
templates---IPPL presents users with a compact, easy-to-read
interface.

<p>This initial release provides multi-dimensional arrays using a
wide variety of storage schemes and parallel decompositions,
multi-threading, and out-of-order execution for maximum performance.
Future versions will include fields, coordinate systems, particles,
parallelism on distributed-memory multicomputers and networks of
workstations using MPI, and many other features.

<p>To see why you might want to build your programs using
IPPL, consider the following simple Laplace solver using
Jacobi iteration on a fixed-size grid:

<blockquote><pre>
#include "Ippl.h"
#include &lt;iostream.h&gt;

// <em>The size of each side of the domain.</em>
const int N = 20;

int
main(
    int                 argc,           // <em>argument count</em>
    char *              argv[]          // <em>argument list</em>
){
    // <em>The array we'll be solving for</em>
    Array&lt;2&gt; x(N, N);
    x = 0.0;

    // <em>The right hand side of the equation (spike in the center)</em>
    Array&lt;2&gt; b(N, N);
    b = 0.0;
    b(N/2, N/2) = -1.0;

    // <em>Specify the interior of the domain</em>
    Interval&lt;1&gt; I(1, N-2), J(1, N-2);

    // <em>Iterate 200 times</em>
    for (int i=0; i&lt;200; ++i)
    {
        x(I,J) = 0.25*(x(I+1,J) + x(I-1,J) + x(I,J+1) + x(I,J-1) - b(I,J));
    }

    // <em>Print out the result</em>
    cout &lt;&lt; x &lt;&lt; endl;
}
</pre></blockquote>

<p>The syntax is very similar to that of Fortran&nbsp;90: a single
assignment fills an entire array with a scalar value, subscripts
express ranges as well as single points, and so on.  In fact, the
combination of C++ and IPPL provides so many of the features
of Fortran&nbsp;90 that one might well ask whether it wouldn't better
to just use the latter language straight up.

<p>One answer comes down to economics.  While the various flavors of
Fortran are still the <em>lingua franca</em> of scientific computing,
Fortran's user base is shrinking, particularly in comparison to C++.
Networking, graphics, database access, and operating system interfaces
are available in C++ programmers long before they're available in
Fortran (if they become available at all).  What's more, support tools
such as debuggers and memory inspectors are primarily targeted at C++
developers, as are hundreds of books, journal articles, and web sites.

<p>Another answer is that the abstraction facilities of C++ are much
more powerful that those in Fortran. While Fortran&nbsp;90 supports
an attractive array syntax for floating point arrays one could not,
for example, efficiently extend this high level syntax to arrays of
vectors or tensors. 

<p>Until recently, Fortran has had two powerful arguments in its
favor: legacy applications, and performance.  However, the importance
of the former is diminishing as the invention of new algorithms force
programmers to rewrite old codes, while the invention of techniques
such as <a href="background.html#expression-templates">expression
templates</a> has made it possible for C++ programs to match, or
exceed, the performance of highly-optimized Fortran&nbsp;77.

<p>IPPL was designed and implemented by scientists working at
PSI .
Between them, these scientists have written and tuned large
applications on almost every commercial and experimental supercomputer
built in the last two decades.  As the technology used in those
machines migrates down into departmental computing servers and desktop
multiprocessors, IPPL is a vehicle for its designers'
experience to migrate as well.  In particular, IPPL's authors
understand how to get good performance out of modern architectures,
with their many processors and multi-level memory hierarchies, and how
to handle the subtly complex problems that arise in real-world
applications.

<p>Finally, IPPL is free for non-commercial use (i.e. your
tax dollars have already paid for it).  You can read its source,
extend it to handle platforms or problem domains that the core
distribution doesn't cater for, or integrate it with other libraries
and your current application, at no cost.  For more information,
please see the <a href="legal.html">license</a> information included
in the appendix.

<p>Of course, nothing is perfect.  As of October 1998, some C++
compilers still do not support the full ANSI/ISO C++ standard.  Please
refer to the <a href="compilers.html">appendix</a>, or see
IPPL's <a href="http://www.acl.lanl.gov/pooma">support
page</a>, for a list of those that do.

<p>A second compiler-related problem is that most compilers produce
very long, and very cryptic, error messages if they encounter an error
while expanding templated functions and classes, particularly if those
functions and classes are nested.  Since IPPL uses templates
extensively, it is not uncommon for a single error to result in
several pages of complaints from a compiler.  The appendix on <a
href="errors.html">error messages</a> discusses some strategies that
can be used to find the root cause of such errors.  Programs that use
templates extensively are also still sometimes slower to compile than
programs that do not, and the executables produced by some compilers
can be surprisingly large.

<p>Finally, some debuggers still provide only limited support for
inspecting templated functions and classes.  All of these problems are
actively being addressed by vendors, primarily in response to the
growing popularity of the <a href="background.html#stl">Standard
Template Library</a>, or STL.  Once again, the large (and growing)
user base for C++ means that scientific programmers can take advantage
of the fact that even the best tools are constantly being improved.

<p>The body of this tutorial starts with a discussion of the <a
href="background.html">background</a> to IPPL, including key
technologies such as caching, compiler optimization, and C++
templates.  The individual tutorials take a simple program---the
Laplace solver shown earlier---and add more and more functionality to
it, until it is able to run on multiple processors, and to control its
own termination by calculating user-defined residuals.

<p>Before you start reading these tutorials, however, you may wish to
take a look at the short <a href="self-test.html">quiz</a> included in
the appendix.  IPPL does require some familiarity with some
of the less well-known features of C++; if you do not feel comfortable
with the questions and their answers, you may wish to have a look at
one of the books in the <a href="reading.html">recommended reading
list</a> before proceeding.

<p>You may also wish to look at the <a
href="http://amas.web.psi.ch">IPPL</a> web site for
updates, bug fixes, and discussion of the library and how it can be
used.  If you have any questions about IPPL or its terms of
use, or if you need help downloading or installing IPPL,
please send mail to <a
href="mailto:andreas.adelmann@ps.ch"><tt>andreas.adelmann@ps.ch</tt></a>.

<br>
<br>
<center>
<table>
<tr>	<td><a href="index.html">[Home]</a>
	<td><a href="background.html">[Next]</a>
	</tr>
</table>
<em>
<a href="">Copyright &copy; PSI </a>
</em>
</center>

</body>
</html>
