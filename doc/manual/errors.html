<!-- errors.html : tail end of POOMA II tutorials -->
<!-- $Id: errors.html,v 1.5 1998/10/26 13:58:03 gvwilson Exp $ -->

<html>
<head>
<title>IPPL Tutorials: Interpreting Error Messages</title>
</head>
<body background="back.gif">

<H1><CENTER><IMG SRC="banner.gif" WIDTH=550 HEIGHT=100
X-SAS-UseImageWidth X-SAS-UseImageHeight ALIGN=bottom></CENTER></H1>

<center><h1>IPPL Tutorials<br>Interpreting Error Messages</h1></center>

<p><b>Contents:</b>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#decipher">How to Decipher Compiler Error Messages</a>
<br>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#assertions">Working with Assertions</a>

<a name="decipher"><h2>How to Decipher Compiler Error Messages</h2></a>

<p>IPPL makes extensive use of templates to achieve high
performance. Unfortunately, this means that a simple mistake often
results in dozens of compiler error messages that are both long and
obscure. These messages are often tough for experienced C++
programmers to interpret and can be downright scary for newcomers to
the language. There is no simple formula for dealing with these
messages, but there are strategies that can reduce the pain associated
with the process.

<p>To begin with, consider the program below:

<blockquote><pre>
01  #include "Pooma/Arrays.h"
02
03  int main(int argc, char *argv[])
04  {
05      Pooma::initialize();
06
07      int p, *pp = &p;    
08      Array<1> z(6);
09      for (p = 0; p < 6; p++)
10          z(pp) = p;
11
12      Pooma::finalize();
13
14      return 0;
15  }
</pre></blockquote>

<p>KCC&nbsp;3.3 reports the following impressive set of error
messages (please be patient while this scrolls past you):

<blockquote><pre>
"src/Array/Array.h", line 416: error: name followed by "::" must be a class or
          namespace name
        CTAssert(SDomain_t::dimensions == dimensions);
        ^
          detected during instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                    Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim, T,
                    Engine>::Domain_t, Sub1>::SliceType_t>::Type_t Array<Dim,
                    T, EngineTag>::operator()(const Sub1 &) const [with Dim=1,
                    T=double, EngineTag=Brick, Sub1=int *]" at line 10 of
                    "test.cpp"

"src/Array/Array.h", line 416: error: class "PoomaCTAssert<<error-constant>>"
          has no member "test"
        CTAssert(SDomain_t::dimensions == dimensions);
        ^
          detected during instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                    Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim, T,
                    Engine>::Domain_t, Sub1>::SliceType_t>::Type_t Array<Dim,
                    T, EngineTag>::operator()(const Sub1 &) const [with Dim=1,
                    T=double, EngineTag=Brick, Sub1=int *]" at line 10 of
                    "test.cpp"

"src/Domain/DomainTraits.Loc.h", line 190: error: a value of type
          "DomainTraitsScalar<int *, int *>::Element_t" cannot be assigned to
          an entity of type "DomainTraits<Loc<1>>::Storage_t"
      dom = DomainTraits<T>::getFirst(newdom);
          ^
          detected during:
            instantiation of "void
                      DomainTraits<Loc<1>>::setDomain(DomainTraits<Loc<1>>::Sto
                      rage_t &, const T &) [with T=int *]" at line 286 of
                      "src/Domain/Domain.h"
            instantiation of "void SetDomainFunctor<DT, ST, T, UT,
                      wildcard>::setDomain(ST &, const T &) [with
                      DT=DomainTraits<Loc<1>>,
                      ST=DomainBase<DomainTraits<Loc<1>>>::Storage_t,
                      T=DomainTraitsScalar<int *, int *>::PointDomain_t,
                      UT=DomainTraitsScalar<int *, int *>::PointDomain_t,
                      wildcard=false]" at line 395 of "src/Domain/Domain.h"
            instantiation of "void Domain<1, DT>::setDomain(const T &) [with
                      DT=DomainTraits<Loc<1>>, T=DomainTraitsScalar<int *, int
                      *>::PointDomain_t]" at line 234 of "src/Domain/Loc.h"
            instantiation of "void CopyLocStorageImpl<Dim, T, 1,
                      false>::copy(Loc<Dim> &, const T &) [with Dim=1, T=int
                      *]" at line 242 of "src/Domain/Loc.h"
            instantiation of "void CopyLocStorage<Dim, T>::copy(Loc<Dim> &,
                      const T &) [with Dim=1, T=int *]" at line 410 of
                      "src/Domain/Loc.h"
            instantiation of "Loc<1>::Loc(const T1 &) [with T1=int *]" at line
                      78 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn2<Engine, Domain, 1>::Type_t
                      ArrayViewReturn2<Engine, Domain, 1>::eval(const Engine
                      &, const Domain &) [with Engine=Engine<1, double,
                      Brick>, Domain=int *]" at line 89 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn<Engine, Domain>::Type_t
                      ArrayViewReturn<Engine, Domain>::eval(const Engine &,
                      const Domain &) [with Engine=Engine<1, double, Brick>,
                      Domain=int *]" at line 418 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                      Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim,
                      T, Engine>::Domain_t, Sub1>::SliceType_t>::Type_t
                      Array<Dim, T, EngineTag>::operator()(const Sub1 &) const
                      [with Dim=1, T=double, EngineTag=Brick, Sub1=int *]" at
                      line 10 of
                      "test.cpp"


"src/Domain/NewDomain.h", line 753: error: name followed by "::" must be a
          class or namespace name
        SliceType_t retval = AllDomain<SliceType_t::dimensions>();
                                       ^
          detected during:
            instantiation of "NewDomain1<T1>::SliceType_t
                      NewDomain1<T1>::combineSlice(const UT &, const T1 &)
                      [with T1=int *, UT=Interval<1>]" at line 128 of
                      "src/Array/ConstArray.h"
            instantiation of "TemporaryNewDomain1<Domain, Sub>::SliceType_t
                      TemporaryNewDomain1<Domain, Sub>::combineSlice(const
                      Domain &, const Sub &) [with Domain=Interval<1>, Sub=int
                      *]" at line 419 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                      Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim,
                      T, Engine>::Domain_t, Sub1>::SliceType_t>::Type_t
                      Array<Dim, T, EngineTag>::operator()(const Sub1 &) const
                      [with Dim=1, T=double, EngineTag=Brick, Sub1=int *]" at
                      line 10 of
                      "test.cpp"

"src/Domain/AllDomain.h", line 84: error: class
          "PoomaCTAssert<<error-constant>>" has no member "test"
      CTAssert(Dim > 0);
      ^
          detected during:
            instantiation of
                      "AllDomain<Dim>::AllDomain() [with Dim=<error-constant>]"
                      at line 753 of "src/Domain/NewDomain.h"
            instantiation of "NewDomain1<T1>::SliceType_t
                      NewDomain1<T1>::combineSlice(const UT &, const T1 &)
                      [with T1=int *, UT=Interval<1>]" at line 128 of
                      "src/Array/ConstArray.h"
            instantiation of "TemporaryNewDomain1<Domain, Sub>::SliceType_t
                      TemporaryNewDomain1<Domain, Sub>::combineSlice(const
                      Domain &, const Sub &) [with Domain=Interval<1>, Sub=int
                      *]" at line 419 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                      Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim,
                      T, Engine>::Domain_t, Sub1>::SliceType_t>::Type_t
                      Array<Dim, T, EngineTag>::operator()(const Sub1 &) const
                      [with Dim=1, T=double, EngineTag=Brick, Sub1=int *]" at
                      line 10 of
                      "test.cpp"

"src/Domain/NewDomain.h", line 753: error: no suitable conversion function
          from "AllDomain<<error-constant>>" to
          "NewDomain1<int *>::SliceType_t" exists
        SliceType_t retval = AllDomain<SliceType_t::dimensions>();
                             ^
          detected during:
            instantiation of "NewDomain1<T1>::SliceType_t
                      NewDomain1<T1>::combineSlice(const UT &, const T1 &)
                      [with T1=int *, UT=Interval<1>]" at line 128 of
                      "src/Array/ConstArray.h"
            instantiation of "TemporaryNewDomain1<Domain, Sub>::SliceType_t
                      TemporaryNewDomain1<Domain, Sub>::combineSlice(const
                      Domain &, const Sub &) [with Domain=Interval<1>, Sub=int
                      *]" at line 419 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                      Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim,
                      T, Engine>::Domain_t, Sub1>::SliceType_t>::Type_t
                      Array<Dim, T, EngineTag>::operator()(const Sub1 &) const
                      [with Dim=1, T=double, EngineTag=Brick, Sub1=int *]" at
                      line 10 of
                      "test.cpp"

"src/Domain/NewDomain.h", line 131: error: expression must have class type
        DomainTraits<RT>::getDomain(rt, DS + i).setDomain(
        ^
          detected during:
            instantiation of "void CombineSliceDomainWC<RT, UT, CT, DS,
                      SliceDS, incl, wc>::combine(RT &, const UT &, const CT
                      &) [with RT=NewDomain1<int *>::SliceType_t,
                      UT=Interval<1>, CT=int *, DS=0, SliceDS=0, incl=false,
                      wc=false]" at line 207
            instantiation of "void CombineSliceDomain<RT, UT, CT, DS, SliceDS,
                      incl>::combine(RT &, const UT &, const CT &) [with
                      RT=NewDomain1<int *>::SliceType_t, UT=Interval<1>,
                      CT=int *, DS=0, SliceDS=0, incl=false]" at line 766
            instantiation of "RT &NewDomain1<T1>::fillSlice(RT &, const UT &,
                      const T1 &) [with T1=int *, RT=NewDomain1<int
                      *>::SliceType_t, UT=Interval<1>]" at line 754
            instantiation of "NewDomain1<T1>::SliceType_t
                      NewDomain1<T1>::combineSlice(const UT &, const T1 &)
                      [with T1=int *, UT=Interval<1>]" at line 128 of
                      "src/Array/ConstArray.h"
            instantiation of "TemporaryNewDomain1<Domain, Sub>::SliceType_t
                      TemporaryNewDomain1<Domain, Sub>::combineSlice(const
                      Domain &, const Sub &) [with Domain=Interval<1>, Sub=int
                      *]" at line 419 of "src/Array/Array.h"
            instantiation of "ArrayViewReturn<ConstArray<Dim, T,
                      Engine>::Engine_t, TemporaryNewDomain1<ConstArray<Dim,
                      T, Engine>::Domain_t, Sub1>::SliceType_t>::Type_t
                      Array<Dim, T, EngineTag>::operator()(const Sub1 &) const
                      [with Dim=1, T=double, EngineTag=Brick, Sub1=int *]" at
                      line 10 of
                      "test.cpp"
</pre></blockquote>

<p>The first thing to keep in mind is that the error messages are
telling you exactly what went wrong in your program.  However, like a
patient speaking to a doctor, the compiler is reporting symptoms: "It
hurts, here, here, and here." It isn't saying directly, "You have
accidentally used an <tt>int*</tt> to index array <tt>z</tt>."

<p>Second, start at the first message and work down. As you can see,
C++ compilers will often report several different error messages for
the same mistake. The first one is usually the most direct statement
of what's wrong so start there. In our example, KCC is reporting an
error at line 416 of the IPPL header
<tt>Array/Array.h</tt>. This line reads:

<blockquote><pre>
CTAssert(SDomain_t::dimensions == dimensions);
</pre></blockquote>

<p>It is specifically complaining about the fact that it doesn't think
<tt>SDomain_t</tt> is a class or namespace name, which means that
qualifying it with '<tt>::</tt>' doesn't make sense. This is a
symptom, but it isn't very useful, especially to someone who isn't
familiar with the innards of IPPL. It may be disconcerting
that the error message is in IPPL code. However, it is simply
the reality with templates that bad user code can result in a template
error deep inside IPPL.

<p>Third, the real information is in the instantiation chain. By
"instantiation chain", we mean the set of templates, starting with
your code, that the C++ compiler was instantiating when it ran into
trouble. In KCC errors, the instantiation chain can be recognized by a
series of lines beginning with "detected during: instantiation
of". The best way to read these chains is from the instantiation
closest to user code to that deepest in IPPL. In the first
error message, this is easy because there is only one instantiation
listed. KCC claims it trying to instantiate:

<blockquote><pre>
Array&lt;Dim, T, Engine&gt;::operator()(const Sub &amp;)
</pre></blockquote>
  
<p>where:
<tt>Dim</tt> is 1,
<tt>T</tt> is <tt>double</tt>,
<tt>EngineTag</tt> is <tt>Brick</tt>,
and
<tt>Sub1</tt> is <tt>int*</tt>,
at line&nbsp;10 of our example program. Now, this is useful because
we see that the problem is with the line:

<blockquote><pre>
z(pp) = p;
</pre></blockquote>

<p>There is indeed a call to <tt>operator()</tt> call on that line,
i.e. <tt>z(pp)</tt>.  Moreover, KCC is telling us that the argument we
passed in has a type <tt>int*</tt>, which is not a legal domain
type. If we change <tt>z(pp)</tt> to <tt>z(p)</tt>, the problem is
solved.

<p>The other error messages give essentially the same information in
different ways. More complicated situations may require following the
instantiation chain through several levels. The most important thing
is not to get blinded by the quantity of output.

<p>The error messages produced by EGCS are formatted differently, but
the procedure for interpreting them is the same. Unfortunately,
CodeWarrior Professional&nbsp;4 does not print out an instantiation
chain, which makes diagnosing template problems very
difficult. Metrowerks knows about this problem and is fixing
it. However, until then, we can only suggest compiling your code with
EGCS or KCC as a means to diagnose difficult problems.

<a name="assertions"><h2>Working with Assertions</h2></a>

<p>IPPL makes extensive use of assertions. An assertion is a
statement by the programmer to the effect that "I think the following
condition should be true." For example, if one creates a one
dimensional array, the domain used to view the data must also be
one-dimensional. Passing a two-dimensional domain to a one-dimensional
array can cause big problems so IPPL code includes an
assertion that the dimensionalities must match.

<p>Assertions can be evaluated either during compilation or during
execution. A compile-time assertion uses template parameters to
synthesize a Boolean template parameter that, if true, causes no code
to be generated and, if false, causes a compilation error. This
assertion appears in IPPL code in the form

<blockquote><pre>
CTAssert(compile_time_bool_expression);
</pre></blockquote>
  
<p>The first two error messages in the output listing in the previous
section are examples of what happens when one of these assertions is
violated.

<p>While IPPL uses <tt>CTAssert</tt> any time there is enough
information during compilation to evaluate an assertion, some
conditions require information that is not available until a program
is executed. For example, it is impossible to determine if arrays in a
data-parallel expression conform during compilation, since the
dimensions of the arrays are set dynamically. Run-time assertions in
IPPL take the form:

<blockquote><pre>
PAssert(run_time_bool_expression);
</pre></blockquote>
  
<p>If exceptions are activated on your platform, <tt>PAssert</tt>
throws an exception if the expression is false. To catch these
exceptions, use code like:

<blockquote><pre>
01  #include "Pooma/Arrays.h"
02
03  int main(int argc, char *argv[])
04  {
05      Pooma::initialize();
06
07      Array<1> x(7), y(7);    
08      Array<1> z(6);
09   
10      try {
11          x = y + z;
12      } 
13      catch (const Pooma::assertion &amp; err) {
14          cout << "Assertion failure: " << err.what() << endl;
15      }
16
17      Pooma::finalize();
18
19      return 0;
20  }
</pre></blockquote>

<p>This code would print out:

<blockquote><pre>
Assertion failure: Expression doesn't conform.
</pre></blockquote>

<p>Some debuggers, like CodeWarrior's, allow you to set a breakpoint
on a C++ exception. This allows you to examine variables, the call
stack, and so on in order to diagnose why the assertion failed. If you
compiled a version of your code with exceptions disabled,
<tt>PAssert</tt> prints out a message and aborts.

<p>If you define the symbol <tt>NOCTAssert</tt>, i.e. include the line:

<blockquote><pre>
#define NOCTAssert
</pre></blockquote>

<p>before any IPPL files are included, <tt>CTAssert</tt>
becomes equivalent to <tt>PAssert</tt>. If you also define
<tt>NOPAssert</tt>, all assertions are removed from your code. The
IPPL makefile stubs turn off assertions for optimized
compiles.

<br>
<br>
<center>
<table>
<tr>	<td><a href="install.html">[Prev]</a>
	<td><a href="index.html">[Home]</a>
	<td><a href="reading.html">[Next]</a>
	</tr>
</table>
</center>

</body>
</html>
