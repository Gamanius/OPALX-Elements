!-----This routine reads in a 1-dim transfer function generated by CMBFAST
!-----then  spline-fits the transfer function and calculates a 3-dim
!-----transfer function at the values needed in the main code

      subroutine cmbfit(nmax,nq,rL,trcmbf,omegatot,omegab,omegadm)

      implicit none

      integer nmax,nq,ii,jj,mm

      real kk1,tf1,tfnorm,tpiL,rL,omegatot,omegab,omegadm

      real kk(nmax),tf(nmax),tf2(nmax),trcmbf(nq,nq,nq)
      real tfcdm(nmax),tfbar(nmax)

!hpf$ distribute kk(block)	
!hpf$ distribute trcmbf(*,*,block)	
!hpf$ align (:) with kk(:) :: tf,tf2,tfcdm,tfbar

      write(6,*)'enter cmbfit'

      tpiL=8.0*atan(1.0)/rL

      open(12,file="cmb.tr",status="old")

      do ii=1,nmax
      read(12,*)kk(ii),tfcdm(ii),tfbar(ii)
      enddo

      close(12)

      tf=tfbar*omegab/omegatot+tfcdm*omegadm/omegatot

      open(13,file="cmb.check")

      do ii=1,nmax
      write(13,*)kk(ii),tf(ii)/maxval(tf)
      enddo

      close(13)

      call spline(kk,tf,nmax,tf2)

      kk1=kk(1)

      write(6,*)kk1

      call splint(kk,tf,tf2,nmax,kk1,tf1)	

      tfnorm=tf1

!      tfnorm=1.0
   

      write(6,*)'Tfnorm=',tfnorm

      open(14,file="cmb.fit")

      do ii=1,nq
      do jj=1,nq
      do mm=1,nq  
    
      kk1=tpiL*((ii-1)**2+(jj-1)**2+(mm-1)**2)**(0.5)   

      call splint(kk,tf,tf2,nmax,kk1,tf1)

      trcmbf(ii,jj,mm)=tf1/tfnorm

      write(14,*)kk1,trcmbf(ii,jj,mm)

      enddo
      enddo
      enddo

      close(14)
      
      return
      end subroutine

!-----Spline-Routine ---------------------------------------------
      
      subroutine spline(x,y,n,y2)

      implicit none

      integer n,i,k

      real x(n),y(n),y2(n),u(n),p(n),sig(n)

!hpf$ distribute x(block)
!hpf$ align (:) with x(:) :: y,y2,u,p,sig

      p=0.0
      y2=0.0    
      u=0.0

      do i=2,n-1
      sig(i)=(x(i)-x(i-1))/(x(i+1)-x(i-1))
      p(i)=sig(i)*y2(i-1)+2.
      y2(i)=(sig(i)-1.)/p(i)
      u(i)=(6.*((y(i+1)-y(i))/(x(i+1)-x(i))-(y(i)-y(i-1))      
     #      /(x(i)-x(i-1)))/(x(i+1)-x(i-1))-sig(i)*u(i-1))/p(i)
      enddo

      y2(n)=0.0

      do k=n-1,1,-1
      y2(k)=y2(k)*y2(k+1)+u(k)
      enddo

      return
      end subroutine

!-----Splint-Subroutine

      subroutine splint(xa,ya,y2a,n,x,y)

      implicit none

      integer n,k,jm,ju,jl,locate,khi,klo

      real a,b,h,x,y
    
      real xa(n),y2a(n),ya(n)

!hpf$ distribute xa(block)
!hpf$ align (:) with xa(:) :: ya,y2a

      klo=1
      khi=n
1     if (khi-klo.gt.1) then
        k=(khi+klo)/2
        if(xa(k).gt.x)then
          khi=k
        else
          klo=k
        endif
      goto 1
      endif
      h=xa(khi)-xa(klo)
      if (h.eq.0.) pause 'bad xa input in splint'
      a=(xa(khi)-x)/h
      b=(x-xa(klo))/h
      y=a*ya(klo)+b*ya(khi)+((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.

      return
      end

